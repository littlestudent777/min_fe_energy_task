# Минимизация свободной энергии и нахождение равновесной ориентации единичного вектора намагниченности
F(x) -> min, где x - приведённый вектор намагниченности
## Содержание

1. [Энергия определяется анизотропией](#оптимизация-анизотропии)
2. [Энергия определяется только влиянием внешнего поля](#оптимизация-энергии-поля)
3. [Примеры использования](#примеры-использования)

---

## Энергия определяется анизотропией

Рассматривается случай кубической анизотропии. 

Задача оптимизации имеет вид:
$$E(x) = K_1 \cdot (x_1^2 x_2^2 + x_2^2 x_3^2 + x_3^2 x_1^2) + K_2 \cdot (x_1^2 x_2^2 x_3^2)$$

При ограничении:
$$x_1^2 + x_2^2 + x_3^2 = 1$$  
Ограничение взято из соображений, что на самом деле компоненты x - это направляющие косинусы

Таким образом, получили задачу с нелинейной функцией цели и с нелинейным ограничением-равенством.

### Основные особенности реализации:
- Отдельно обрабатывается случай, когда есть только компонента (`K1`).
- Используется метод SLSQP для поиска минимума. 

### Методы:
- `_f_without_K2(x)`: Вычисляет энергию для одноосной анизотропии
- `_f_with_K2(x)`: Вычисляет энергию для кубической анизотропии
- `optimize(tol, max_iter)`: Запускает оптимизацию и возвращает лучшее решение

---

## Энергия определяется только влиянием внешнего поля

Класс `FieldEnergyOptimizer` минимизирует энергию, создаваемую внешним магнитным полем, для определения равновесной ориентации намагниченности.

### Основные особенности:
- Реализует метод проекции градиента
- Обеспечивает ограничение на единичный вектор через проекцию
- Использует постоянный шаг для градиентного спуска (оптимально для линейных функций)
- Настраиваемые параметры точности и числа итераций

### Методы:
- `f(x)`: Вычисляет энергию поля
- `projection(x)`: Проецирует вектор на единичную сферу
- `projected_gradient()`: Запускает оптимизацию и возвращает решение

---

## Примеры использования

### Оптимизация анизотропии
```python
param_combinations = [
    (4.2, None),    # Ось легкого намагничивания (100)
    (-4.2, None),   # Ось легкого намагничивания (111)
    (4.2, 1.5),     # Ось легкого намагничивания (100)
]

for K1, K2 in param_combinations:
    optimizer = AnisotropyOptimizer(K1, K2)
    result = optimizer.optimize()
    print(f"K1={K1}, K2={K2} -> Решение: {result['solution']}")
