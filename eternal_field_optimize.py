import numpy as np


class FieldEnergyOptimizer:
    """Optimizer for energy generated by an external magnetic field minimization.
       Finds the equilibrium orientation of magnetization"""
    def __init__(self, M_s, H, tol=1e-6):
        self.M_s = M_s
        self.H = H
        self.tol = tol
        # Gradient is constant here, so we will count it once along with initialization
        self.grad_f = np.array([- M_s * H[0], - M_s * H[1], - M_s * H[2]])

    def f(self, x):
        """Objective function F(x) -> min"""
        return - self.M_s * np.dot(x, self.H)

    def projection(self, x):
        """Check if the point lies within the bounds.
            If not - return its projection."""
        constraint = sum(x ** 2) - 1
        if abs(constraint) > self.tol:
            # Euclidean norm
            return x / np.linalg.norm(x)
        else:
            return x

    def projected_gradient(self, max_iter=1000):
        """Gradient projection method
        Constant step was chosen, because function is linear and steepest descent wouldn't work with it

        Returns:
        tuple: (optimal point, function value at that point)
        """
        # Random start point
        x = self.projection(np.random.sample(3))

        step = 1.0
        direction = - self.grad_f  # Antigradient
        
        for it in range(max_iter):
            x_new = self.projection(x + step * direction)
            if np.linalg.norm(x_new - x) < self.tol:
                x = x_new
                break
            x = x_new

        return x, self.f(x)


# Generate random H vectors to run test
H_array = [np.random.uniform(-10, 10, 3) for _ in range(10)]
M_s = 1.707  # in 10^3 emu/cc

for H in H_array:
    H_norm = np.linalg.norm(H)
    print(f"\nH direction: {[f'{H_i / H_norm:.3f}' for H_i in H]}")
    optimizer = FieldEnergyOptimizer(M_s, H)
    result = optimizer.projected_gradient()

    print(f"Solution: {[f'{x:.3f}' for x in result[0]]}")
    print(f"f(x) = {result[1]:.6f} * 10^3 ergs/cc")
