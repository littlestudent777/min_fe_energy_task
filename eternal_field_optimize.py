import numpy as np


class FieldEnergyOptimizer:
    """Optimizer for energy generated by an external magnetic field minimization.
       Finds the equilibrium orientation of magnetization"""
    def __init__(self, M, H, tol=1e-6, max_iter=1000):
        self.M = M
        self.H = H
        self.tol = tol
        self.max_iter = max_iter
        # Gradient is constant here, so we will count it once along with initialization
        self.grad_f = np.array([- M * H[0], - M * H[1], - M * H[2]])

    def f(self, x):
        """Objective function F(x) -> min"""
        return - self.M * np.dot(x, self.H)

    @staticmethod
    def constraint(x):
        """Returns value on constraint equation: phi(x) = 0 """
        return np.linalg.norm(x) - 1.0

    def projection(self, x):
        """Check if the point lies within the bounds.
            If not - return its projection."""
        if abs(self.constraint(x)) > self.tol:
            # Euclidean norm
            return x / np.linalg.norm(x)
        else:
            return x

    def projected_gradient(self):
        """Gradient projection method
        Constant step was chosen, because function is linear and steepest descent wouldn't work on it
        """
        x_prev = np.random.sample(3)
        x = self.projection(x_prev)

        step = 1

        for it in range(self.max_iter):
            x = self.projection(x - step * self.grad_f)
            if np.linalg.norm(x - x_prev) < self.tol:
                break
            x_prev = x

        f_val = self.f(x)

        return x, f_val


H_array = [np.random.uniform(-10, 10, 3) for _ in range(10)]
M = 1.707  # in 10^3 emu/cc

for H in H_array:
    H_norm = np.linalg.norm(H)
    print(f"\nH direction: {[f'{H_i / H_norm:.3f}' for H_i in H]}")
    optimizer = FieldEnergyOptimizer(M, H)
    result = optimizer.projected_gradient()

    print(f"Solution: {[f'{x:.3f}' for x in result[0]]}")
    print(f"f(x) = {result[1]:.6f}")
