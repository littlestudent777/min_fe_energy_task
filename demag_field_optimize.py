import numpy as np
from math import sqrt


class DemagEnergyOptimizer:
    """Optimizer for energy generated by demagnetizing field minimization.
       Finds the equilibrium orientation of magnetization"""
    def __init__(self, M_s, N, tol=1e-6):
        self.M_s = M_s
        self.N = N
        self.tol = tol

    def f(self, x):
        """Objective function: demagnetizing field energy F(x) -> min"""
        return 2 * np.pi * (self.M_s ** 2) * (self.N[0] * x[0] ** 2
                                              + self.N[1] * x[1] ** 2
                                              + self.N[2] * x[2] ** 2)

    def grad(self, x):
        """ Returns grad(f(x)) """
        return 4 * np.pi * (self.M_s ** 2) * np.array([self.N[0] * x[0],
                                                      self.N[1] * x[1],
                                                      self.N[2] * x[2]])

    def projection(self, x):
        """Check if the point lies within the bounds.
            If not - return its projection."""
        constraint = sum(x ** 2) - 1
        if abs(constraint) > self.tol:
            # Euclidean norm
            return x / np.linalg.norm(x)
        else:
            return x

    def golden_section_search(self, x, d, a=0.0, b=1.0, max_iter=100):
        """Golden section search optimization.

           Returns:
               optimal step value"""
        rho = (3 - sqrt(5)) / 2
        c1 = a + rho * (b - a)
        c2 = b - rho * (b - a)
        f1 = self.f(x + d * c1)
        f2 = self.f(x + d * c2)

        for it in range(max_iter):
            if abs(c1 - c2) < self.tol:
                break

            if f1 < f2:
                b = c2
                c2 = c1
                f2 = f1
                c1 = a + rho * (b - a)
                f1 = self.f(x + d * c1)
            else:
                a = c1
                c1 = c2
                f1 = f2
                c2 = b - rho * (b - a)
                f2 = self.f(x + d * c2)
        else:  # no break
            print(f"Golden search reached max iterations ({max_iter})")

        return (a + b) / 2

    def projected_gradient(self, max_iter=1000):
        """Gradient projection method with steepest descent

        Returns:
            tuple: (optimal point, function value at that point)
        """
        # Random start point
        x = self.projection(np.random.sample(3))
        grad = self.grad(x)

        for it in range(max_iter):
            # Antigradient direction
            direction = grad * (-1.0)

            # Find optimal step using the golden section method
            step = self.golden_section_search(x, direction)

            x_new = self.projection(x + step * direction)
            # if np.linalg.norm(x_new - x) < self.tol:
            grad = self.grad(x_new)
            if np.linalg.norm(grad) < self.tol:
                x = x_new
                break
            x = x_new
        else:  # no break
            print(f"Projected gradient reached max iterations ({max_iter})")

        return x, self.f(x)


# Additional function to make output clearer
def get_direction_description(m, tol=1e-6):
    """Returns magnetization direction"""
    axes = ['X', 'Y', 'Z']
    m_abs = np.abs(m)
    max_idx = np.argmax(m_abs)

    # If one component is close to one, then vector is along this axis
    if np.abs(m[max_idx] - 1.0) < tol:
        return f"along {axes[max_idx]}"

    # If there is no close to one component and there is one close to zero
    zero_comps = m_abs < tol
    if np.sum(zero_comps) == 1:
        plane_axes = [axes[i] for i in range(3) if not zero_comps[i]]
        return f"in {''.join(plane_axes)} plane"

    # Else
    return "no preferred direction"


# Run optimization for different configurations:
M_s = 1.707  # in 10^3 emu/cc

configs = [
    ("Cylinder (z is inf)", np.array([0.5, 0.5, 0.0])),
    ("Plate (x and y are inf)", np.array([0.0, 0.0, 1.0])),
    ("Sphere", np.array([1/3, 1/3, 1/3])),
]

for name, N in configs:
    print(f"\nConfiguration: {name}")
    print(f"Demagnetizing factor: N_11 = {N[0]:.1f},  N_22 = {N[1]:.1f},  N_33 = {N[2]:.1f}")

    optimizer = DemagEnergyOptimizer(M_s, N)
    m_opt, energy = optimizer.projected_gradient()
    direction_desc = get_direction_description(m_opt)
    print(f"   Optimum magnetization: m = {[f'{m_i:.3f}' for m_i in m_opt]}")
    print(f"   F(m) = {energy:.3f} Ã— 1e+6 ergs/cc")
    print(f"   Direction: {direction_desc}")

